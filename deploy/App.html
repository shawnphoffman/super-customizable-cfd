<!DOCTYPE html>
<html>
<head>
    <title>Super Customizable Cumulative Flow Diagram</title>
    <!--  (c) 2013 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Jun 05 2014 16:46:35 GMT-0400 (EDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Jun 05 2014 16:46:35 GMT-0400 (EDT)";
        var CHECKSUM = 68414074913;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * a calculator for each day of data,
 * given a snap for that day, will calculate a
 * total count for each value in a metric field (e.g., count the number of items in Defined schedule state)
 * 
 * assumes that each individual snap represents one unique item
 */
 
 Ext.define('TSDay',{
    extend: 'Ext.data.Model',
    group_totals: {},
    fields: [
        {name:'JSDate',type:'date',defaultValue:new Date()},
        {name:'groupByFieldName',type:'string',defaultValue:'ScheduleState'}, /* the name of the field that filters what we count */
        {name:'metricFieldName',type:'string',defaultValue:'Count'}, /* the name of the field with a value to add (or count), remember the c_! */
        {name:'Total',type:'number',defaultVale:0}
    ],
    constructor: function(data) {
        this.group_totals = {};
        this.callParent(arguments);
    },
    /**
     * Given a single lookback snapshot, aggregate data
     * @param {} snap
     */
    addSnap: function(snap){
        var total = this.get('Total');
        var group_by_field_name = this.get('groupByFieldName');
        var metric_field_name = this.get('metricFieldName');
        
        var value_in_snap = 0;
        if ( metric_field_name === "Count" ) {
            value_in_snap = 1;
        } else {
            if (Ext.isNumber(snap.get(metric_field_name))) {
                value_in_snap = snap.get(metric_field_name);
            }
        }
        total = total + value_in_snap;
        this.set('Total',total);
        
        var snap_value = snap.get(group_by_field_name);
        
        if ( Ext.isDefined(snap_value) ) {
            if ( Ext.isBoolean(snap_value) ) { 
                if ( snap_value ) { 
                    snap_value = "true"; 
                } else { 
                    snap_value = "false"; 
                } 
            }
            if ( ! this.group_totals[snap_value] ) { this.group_totals[snap_value] = 0; }
            this.group_totals[snap_value] = this.group_totals[snap_value] + value_in_snap;
        }
    },
    /**
     * return the aggregated value of totals for a given group (as seen in the groupByFieldName
     * (assumes if we haven't heard about the field value yet, it's just 0
     */
    getGroupTotal: function(field_value){
        return this.group_totals[field_value] || 0 ;
    }
    
 });

/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>TS</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});
/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.SettingsDialog',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tssettingsdialog',
    config: {
        /* default settings. pass new ones in */
        title: 'Settings',
        model_type: 'HierarchicalRequirement',
        /**
         * artifact_types
         * [ @type ] artifact_types This is the list of items allowed in the model chooser drop down
         */
        artifact_types: [
            {Name:'HierarchicalRequirement',Value:'HierarchicalRequirement'},
            {Name:'Defect',Value:'Defect'}
        ],
        group_by_field_name: 'Schedulestate',
        metric: 'Count',
        start_date:Rally.util.DateTime.add(new Date(),"month",-1),
        end_date: Rally.util.DateTime.add(new Date(),"day",-1),
        // start_date: this._getStartDate(),
        // end_date: this._getEndDate(),
        /**
         * A string to apply to choose records that are allowed in the calculations --
         * this query is applied to items as they exist now, and then all the calculations are
         * about only those records as they were during the time period.
         *
         * This can make everything slow, because it adds a WsapiCall on top of the LookBack calls
         */
         query_string: null
    },
    items: {
        xtype: 'panel',
        border: false,
        defaults: {
            padding: 5,
            margin: 5
        },
        items: [
            {
                xtype: 'container',
                itemId: 'model_selector_box'
            },
            {
                xtype:'container',
                itemId: 'group_field_selector_box'
            },
            {
                xtype:'container',
                itemId: 'metric_selector_box'
            },
            {
                xtype:'container',
                itemId:'start_date_selector_box'
            },
            {
                xtype:'container',
                itemId:'end_date_selector_box'
            },
            {
                xtype:'container',
                itemId:'query_selector_box'
            }
        ]
    },
    constructor: function(config){
        this.mergeConfig(config);
        this.callParent([this.config]);

    },
    initComponent: function() {
        this.callParent(arguments);
        this.addEvents(
            /**
             * @event settingsChosen
             * Fires when user clicks done after making settings choices
             * @param {Rally.technicalservices.SettingsDialog} this
             * @param {hash} config settings
             */
            'settingsChosen',
            /**
             * @event cancelChosen
             * Fires when user clicks the cancel button
             */
            'cancelChosen'
        );
        this._buildButtons();
        this._addChoosers();
    },
    _buildButtons: function() {
        this.down('panel').addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    text: 'Run',
                    scope: this,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('settingsChosen', this, this._getConfig());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    handler: function() {
                        this.fireEvent('cancelChosen');
                        this.close()
                    },
                    scope: this
                }
            ]
        });
    },
    _getIteration: function() {
        return this.getContext().getTimeboxScope().getRecord();
    },
    _getStartDate: function() {
        return this._getIteration().get('StartDate');
    },
    _getEndDate: function() {
        return this._getIteration().get('EndDate');
    },
    _getConfig: function() {
        var config = {};
        if ( this.down('#model_chooser') ) {
            config.model_type = this.down('#model_chooser').getValue();
        }
        if ( this.down('#group_field_chooser') ) {
            config.group_by_field_name = this.down('#group_field_chooser').getValue();
            config.group_by_field_type = this.down('#group_field_chooser').getRecord().get('fieldDefinition').attributeDefinition.AttributeType;
        }
        if ( this.down('#metric_chooser') ) {
            config.metric = this.down('#metric_chooser').getValue();
        }

        if ( this.down('#start_date_chooser') ) {
            config.start_date = this.down('#start_date_chooser').getValue();
        }
        if ( this.down('#end_date_chooser') ) {
            config.end_date = this.down('#end_date_chooser').getValue();
        }
        if ( this.down('#query_chooser') ) {
            config.query_string = this.down('#query_chooser').getValue();
        }
        return config;
    },
    _addChoosers: function() {
        var me = this;
        this._addModelChooser();
        this._addGroupChooser();
        this._addMetricChooser();
        this._addDateChoosers();
        this._addQueryChooser();

    },
    _addModelChooser: function() {
        var me = this;
        var type_store = Ext.create('Rally.data.custom.Store',{
            data: me.artifact_types
        });
        this.down('#model_selector_box').add({
            xtype:'rallycombobox',
            itemId: 'model_chooser',
            displayField: 'Name',
            valueField: 'Value',
            store: type_store,
            fieldLabel: 'Artifact Type',
            labelWidth: 75,
            value: me.model_type,
            listeners: {
                scope: this,
                change: function(cb,new_value){
                    this.model_type = new_value;
                    this.group_by_field_name = null;
                    this.metric = "Count";
                    this._addGroupChooser();
                    this._addMetricChooser();
                }
            }
        });
    },
    _addGroupChooser: function() {
        var me = this;

        this.down('#group_field_selector_box').removeAll();
        var cb = this.down('#group_field_selector_box').add({
            xtype:'rallyfieldcombobox',
            itemId: 'group_field_chooser',
            model: me.model_type,
            value: me.group_by_field_name,
            labelWidth: 75,
            fieldLabel: 'Group By'
        });
        var field_store = cb.getStore();
        field_store.on({
            'load': {
                fn: function(store,records) {
                    me._filterOutExceptChoices(store,records);
                    if ( me.group_by_field_name === null ) {
                        cb.setValue(store.getAt(0));
                    }
                },
             'scope': me
            }
        });

    },
    _addMetricChooser: function() {
        var me = this;

        this.down('#metric_selector_box').removeAll();
        var cb = this.down('#metric_selector_box').add({
            xtype:'rallyfieldcombobox',
            itemId: 'metric_chooser',
            model: me.model_type,
            value: me.metric,
            labelWidth: 75,
            fieldLabel: 'Measure'
        });
        var field_store = cb.getStore();
        field_store.on('load',this._filterOutExceptNumbers,this,true);
        field_store.on({
            'load':{
                fn: function() {
                    field_store.add({name:'Count',value:'Count',fieldDefinition:{}});
                    cb.setValue(me.metric);
                },
                single: true
            }
        });
    },
    _addDateChoosers: function() {
        var me = this;
        this.down('#start_date_selector_box').add({
            xtype: 'rallydatefield',
            fieldLabel: 'Start Date',
            itemId: 'start_date_chooser',
            labelWidth: 75,
            value: me.start_date,
            validator: me._dateValidator
        });

        this.down('#end_date_selector_box').add({
            xtype: 'rallydatefield',
            fieldLabel: 'End Date',
            itemId:'end_date_chooser',
            labelWidth: 75,
            value: me.end_date,
            validator: me._dateValidator
        });
    },
    _addQueryChooser: function() {
        var me = this;
        this.down('#query_selector_box').add({
            xtype:'textareafield',
            grow: true,
            itemId:'query_chooser',
            labelAlign: 'top',
            fieldLabel:'Limit to items that currently meet this query filter',
            value: me.query_string
        });
    },
    _dateValidator: function(value) {
        return true;
    },
    _filterOutExceptChoices: function(store,records) {
        store.filter([{
            filterFn:function(field){
                var attribute_type = field.get('fieldDefinition').attributeDefinition.AttributeType;
                if (  attribute_type == "BOOLEAN" ) {
                    return true;
                }
                if ( attribute_type == "STRING" || attribute_type == "STATE" ) {
                    if ( field.get('fieldDefinition').attributeDefinition.Constrained ) {
                        return true;
                    }
                }
                if ( field.get('name') === 'State' ) {
                    return true;
                }
                //console.log(field.get('name'),field.get('fieldDefinition').attributeDefinition.AttributeType);
                return false;
            }
        }]);
    },
    _filterOutExceptNumbers: function(store,records) {
      console.log(store);
        store.filter([{
            filterFn:function(field){
                var attribute_type = field.get('fieldDefinition').attributeDefinition.AttributeType;
                if (  attribute_type == "QUANTITY" || attribute_type == "INTEGER" || attribute_type == "DECIMAL" ) {
                    return true;
                }
                if ( field.get('name') == 'Count' ) { return true; }
                return false;
            }
        }]);
    }

});

Ext.define('TSStringFilter',{
    extend: 'Rally.data.QueryFilter',
    config: {
        query_string: ''
    },
    constructor: function(config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },
    _createQueryString: function(property, operator, value) {
        this.filter = this.fromQueryString(this.query_string);
        return this.filter.toString();
    },
    /**
     * Converts a query string into a Rally compatible QueryFilter
     * @static
     * @param {String} query The query string to convert into a QueryFilter
     * @return {Rally.data.wsapi.Filter} A Rally.data.wsapi.Filter that will convert back to a query string if toString() is called
     */
    fromQueryString: function (query) {
        var parser = Ext.create('Rally.data.util.QueryStringParser', {
            string: query
        });

        var initial_expression = parser.parseExpression();
        return initial_expression;
    }
});
Ext.override(Rally.data.util.QueryStringParser,{
  applyOperators: function (operators, operator) {
        if (!operators.length) {
            return this.parseNextTerm();
        }

        if (!operator) {
            operator = operators[0];
        }

        var property = this.applyOperators(operators.slice(1));

        while (this.peek() === operator) {
            this.consume(operator);
            var value = this.applyOperators(operators.slice(1));
            if ( operator == "AND" || operator == "OR" ) {
                property = Ext.create('Rally.data.QueryFilter', {
                    property: property,
                    operator: operator,
                    value: this._convertToType(value)
                });
            } else {
                value = this._convertKeywords(property,operator,value);
                if (typeof(value) == "object" ) {
                    property = value;
                } else {
                    property = Ext.create('Rally.data.QueryFilter', {
                        property: property,
                        operator: operator,
                        value: this._convertToType(value)
                    });
                }
            }
        }
        return property;
    },
    /**
     * Do date math
     **/
    _convertKeywords: function(property,operator,value) {
        var xform_value = value;
        if ( operator != "AND" && operator != "OR" ) {
            if ( this._isDateKeyword(value) ) {
                var base_js_date = this._getBaseJSDate(value);
                if ( operator == "<" || operator == ">" || operator == ">=") {
                    xform_value = this._getIsoMidnight(base_js_date);
                } else if ( operator == "<=") {
                    xform_value = this._getIsoMidnight(Rally.util.DateTime.add(base_js_date,"day",1));
                } else if ( operator == "=" ) {
                    // yesterday and tomorrow do NOT include today, but all others do
                    if ( value == "tomorrow" || value == "yesterday" || value == "today") {
                        xform_value = Ext.create('Rally.data.QueryFilter', {
                            property: property,
                            operator: ">",
                            value: this._getIsoMidnight(base_js_date)
                        }).and(Ext.create('Rally.data.QueryFilter', {
                            property: property,
                            operator: "<",
                            value: this._getIsoMidnight(Rally.util.DateTime.add(base_js_date,"day",1))
                        }));                        
                    } else {
                        // everything less than today
                        var date_1 = base_js_date;
                        var date_2 = new Date();
                        
                        if ( date_1 > date_2 ) {
                            // include today by starting at beginning of day
                            xform_value = Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: ">",
                                value: this._getIsoMidnight(date_2)
                            }).and(Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: "<",
                                value: this._getIsoMidnight(date_1)
                            }));
                        } else {
                            // include today by starting at end of day when going back
                            xform_value = Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: ">",
                                value: this._getIsoMidnight(date_1)
                            }).and(Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: "<",
                                value: this._getIsoMidnight(Rally.util.DateTime.add(date_2,"day",1))
                            }));
                        }
                    }
                }
            }
        } 
        return xform_value;
    },
    _getBaseJSDate: function(keyword){
        var lc_keyword = Ext.util.Format.lowercase(keyword);
        var today = new Date();
        return Rally.util.DateTime.add(today,"day",this.periodShifters[lc_keyword]);
    },
    _isDateKeyword: function(keyword) {
        var isKeyword = false;
        var valid_keywords = [
            "today", "tomorrow", "yesterday",
            "lastweek","lastmonth","lastquarter","lastyear",
            "nextweek","nextmonth","nextquarter","nextyear"
        ];
        if ( Ext.Array.indexOf(valid_keywords,Ext.util.Format.lowercase(keyword)) > -1 ) {
            isKeyword = true;
        }
        return isKeyword;
    },
    periodShifters: {
        "today": 0,
        "tomorrow":1, 
        "yesterday":-1,
        "lastweek":-6,
        "lastmonth":-29,
        "lastquarter":-89,
        "lastyear":-364,
        "nextweek":7,
        "nextmonth":30,
        "nextquarter":90,
        "nextyear":365       
    },
    /**
     * 
     */
    _getIsoMidnight: function(js_date) {
        var js_at_midnight = new Date(Ext.clone(js_date).setHours(0,0,0,0));
        var iso_at_midnight = Rally.util.DateTime.toIsoString(js_at_midnight).replace(/T.*$/,"");
        return iso_at_midnight;
    }
});
Ext.define('Rally.technicalservices.util.Utilities', {
    singleton: true,
    hashToArray: function(hash) {
        var result = [];
        for ( var key in hash ) {
            result.push(hash[key]);
        }
        return result;
    },
    daysBetween: function(begin_date_js,end_date_js,skip_weekends){

        if ( typeof(begin_date_js) == "string" ) {
            begin_date_js = Rally.util.DateTime.fromIsoString(begin_date_js);
        }
        if ( typeof(end_date_js) == "string" ) {
            end_date_js = Rally.util.DateTime.fromIsoString(end_date_js);
        }
        
        var dDate1 = Ext.clone(begin_date_js).setHours(0,0,0,0);
        var dDate2 = Ext.clone(end_date_js).setHours(0,0,0,0);
        
        if ( dDate1 == dDate2 ) { return 0; }
        if (typeof dDate1 === "number") { dDate1 = new Date(dDate1); }
        if (typeof dDate2 === "number") { dDate2 = new Date(dDate2); }
            
        if ( !skip_weekends ) {
            return Math.abs( Rally.util.DateTime.getDifference(dDate1,dDate2,'day') );
        } else {
            // from the sOverflow
            var iWeeks, iDateDiff, iAdjust = 0;
            if (dDate2 < dDate1) 
            { 
                var x = dDate2;
                dDate2 = dDate1;
                dDate1 = x;
            }
            var iWeekday1 = dDate1.getDay(); // day of week
            var iWeekday2 = dDate2.getDay();
            iWeekday1 = (iWeekday1 == 0) ? 7 : iWeekday1; // change Sunday from 0 to 7
            iWeekday2 = (iWeekday2 == 0) ? 7 : iWeekday2;
            if ((iWeekday1 > 5) && (iWeekday2 > 5)) iAdjust = 1; // adjustment if both days on weekend
            iWeekday1 = (iWeekday1 > 5) ? 5 : iWeekday1; // only count weekdays
            iWeekday2 = (iWeekday2 > 5) ? 5 : iWeekday2;
    
            // calculate differnece in weeks (1000mS * 60sec * 60min * 24hrs * 7 days = 604800000)
            iWeeks = Math.floor((dDate2.getTime() - dDate1.getTime()) / 604800000)
    
            if (iWeekday1 <= iWeekday2) {
              iDateDiff = (iWeeks * 5) + (iWeekday2 - iWeekday1)
            } else {
              iDateDiff = ((iWeeks + 1) * 5) - (iWeekday1 - iWeekday2)
            }
    
            iDateDiff -= iAdjust // take into account both days on weekend
    
            if ( iDateDiff < 0 ) { iDateDiff = 0; }
            return (iDateDiff); 
        }
    },

    isWeekday: function(check_date) {
        var weekday = true;
        var day = check_date.getDay();
        
        if ( day === 0 || day === 6 ) {
            weekday = false;
        }
        return weekday;
    },
    
    /*
     * compress size is the point at which to move to weeks instead of days
     */
    arrayOfDaysBetween: function(begin_date_js, end_date_js, skip_weekends, compress_size ) {
        var the_array = [];
        if ( typeof(begin_date_js) == "string" ) {
            begin_date_js = Rally.util.DateTime.fromIsoString(begin_date_js);
        }
        if ( typeof(end_date_js) == "string" ) {
            end_date_js = Rally.util.DateTime.fromIsoString(end_date_js);
        }
        if ( begin_date_js > end_date_js ) {
            var swap_holder = end_date_js;
            end_date_js = begin_date_js;
            begin_date_js = swap_holder;
        }
                
        var dDate1 = Ext.clone(begin_date_js).setHours(0,0,0,0);
        var dDate2 = Ext.clone(end_date_js).setHours(0,0,0,0);
        
        var number_of_days = this.daysBetween(begin_date_js,end_date_js,skip_weekends);
        
        var add_value = 1;
        var add_unit = 'day';
        
        if ( Ext.isNumber(compress_size) && number_of_days > compress_size ) {
            add_value = 7;
        }
        
        if ( number_of_days <= 2 ) {
            add_value = 30;
            add_unit = 'minute';
            dDate2 = Ext.clone(end_date_js).setHours(23,59,0,0);
        }
       
        
        var check_date = new Date(dDate1);
        
        while (check_date <= dDate2) {
            if ( !skip_weekends || this.isWeekday(check_date) || add_value === 7 || add_unit == 'minute' ) {
                the_array.push(check_date);
            }
            check_date = Rally.util.DateTime.add(check_date,add_unit,add_value);
        }
        
        return the_array;
    }
    
});
Ext.define('CustomApp', {
    extend: 'Rally.app.TimeboxScopedApp',
    scopeType: 'iteration',
    componentCls: 'app',
    key: 'rally.techservices.supercfd',
    config: {
        model_type:'HierarchicalRequirement',
        start_date: Rally.util.DateTime.add(new Date(),"month",-3),
        end_date: Rally.util.DateTime.add(new Date(),"day",-1),
        group_by_field_name: 'ScheduleState',
        metric: 'Count',
        groups:[],
        /**
         * At this number of days, switch to displaying by week instead of by day
         * @type Number
         */
        day_to_week_switch_point: 45,
        query_string: null
    },
    logger: new Rally.technicalservices.Logger(),
    items: [
        // {xtype:'rallyiterationcombobox', itemId:'iterationComboBox', cls:'wide-dropdown'},
        {xtype:'container',itemId:'selector_box', margin: 5, padding: 5},
        {xtype:'container',itemId:'chart_box', margin: 10, padding: 10}
        // {xtype:'tsinfolink',informationHtml:"<strong>Super-Customizable Date-Driven Area Chart</strong>"}
    ],
    onScopeChange: function(scope) {
      this.config.start_date = scope.getRecord().get('StartDate');
      this.config.end_date   = scope.getRecord().get('EndDate');
      this.config.query_string = '(Iteration.Name = "' + scope.getRecord().get('Name') + '")';
      this._reCalculate();
    },
    launch: function() {
        this.logger.log("Launched with context", this.getContext(), "and config", this.config);
        console.log('Start Date: ' + this.getContext().getTimeboxScope().getRecord().get('StartDate'));
        console.log('End Date: ' + this.getContext().getTimeboxScope().getRecord().get('EndDate'));
        var me = this;
        me._getSettings();
        this._getPITypes().then({
            success: function(pi_types) {
                me.down('#selector_box').add({
                    xtype:'rallybutton',
                    text:'Settings',
                    handler: function() {
                        me._showSettingsDialog();
                    },
                    scope: me
                });
            },
            failure: function(error) {
                alert(error);
            }
        });
    },
    _getSettings: function() {
        var me = this;
        Rally.data.PreferenceManager.load({
            appID: me.getAppId(),
            success: function(prefs) {
                //process prefs
                me.logger.log(prefs);
                if ( prefs && prefs[me.key] ) {
                    me.config = Ext.JSON.decode(prefs[me.key]);
                    if ( typeof(me.config.start_date) == "string" ) {
                        // me.config.start_date = Rally.util.DateTime.fromIsoString(me.config.start_date);
                        me.config.start_date = me.getContext().getTimeboxScope().getRecord().get('StartDate');
                    }
                    if ( typeof(me.config.end_date) == "string" ) {
                        // me.config.end_date = Rally.util.DateTime.fromIsoString(me.config.end_date);
                        me.config.end_date = me.getContext().getTimeboxScope().getRecord().get('EndDate');
                    }
                    me.config.query_string = '(Iteration.Name = "' + me.getContext().getTimeboxScope().getRecord().get('Name') + '")';
                    me._reCalculate();
                }
            }
        });
    },
    _getPITypes: function() {
        var me = this;
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.WsapiDataStore',{
            model: 'TypeDefinition',
            filters: [{property:'TypePath',operator:'contains',value:'PortfolioItem/'}],
            autoLoad: true,
            listeners: {
                load: function(store,types) {
                    me.config.artifact_types = [
                        {Name:'HierarchicalRequirement',Value:'HierarchicalRequirement'},
                        {Name:'Defect',Value:'Defect'},
                        {Name:'Task',Value:'Task'}
                    ];

                    Ext.Array.each(types, function(type){
                        me.config.artifact_types.push({
                            Name:type.get('DisplayName'),
                            Value:type.get('TypePath')
                        });
                    });
                    deferred.resolve(types);
                }
            }
        });
        return deferred.promise;
    },
    _showSettingsDialog: function() {
        if ( this.dialog ) { this.dialog.destroy(); }
        var config = this.config;
        var me = this;

        this.dialog = Ext.create('Rally.technicalservices.SettingsDialog',{
            model_type: config.model_type,
            group_by_field_name: config.group_by_field_name,
            metric: config.metric,
            start_date: config.start_date,
            end_date: config.end_date,
            artifact_types: config.artifact_types,
            query_string: config.query_string,
            listeners: {
                settingsChosen: function(dialog,returned_config) {
                    this.config = Ext.Object.merge(this.config,returned_config);
                    this.logger.log("new config",this.config);
                    if ( this.config.start_date < new Date(2011,10,11) ) { this.config.start_date = new Date(2011,10,11); }
                    if ( this.config.end_date < new Date(2011,10,11) ) { this.config.end_date = new Date(2011,10,11); }

                    var settings = {};
                    settings[this.key] = Ext.JSON.encode(this.config);
                    Rally.data.PreferenceManager.update({
                        appID: me.getAppId(),
                        settings: settings,
                        success: function(updatedRecords, notUpdatedRecords) {
                            //yay!
                        }
                    });
                    this._reCalculate();
                },
                scope: this
            }
        });
        this.dialog.show();
    },
    _reCalculate:function() {
        var me = this;
        this.down('#chart_box').removeAll();
        this.getEl().mask("Loading");

        this.config.limit_to_oids = null;

        if ( this.config.query_string ) {
            this.logger.log("Using query:",this.config.query_string);

            this._limitRecordsByQuery(this.config.model_type, this.config.query_string).then({
                success: function(oids){
                    me.config.limit_to_oids = oids;
                    me._recalculateLookBack();
                },
                failure: function(error) {
                    alert("Error while trying to apply filter");
                    me.getEl().unmask();
                }
            });
        } else {
            this._recalculateLookBack(null);
        }
    },
    _limitRecordsByQuery: function(model,query_string) {
        this.logger.log("_limitRecordsByQuery");
        this.getEl().mask("Loading Filter Data");

        var deferred = Ext.create('Deft.Deferred');

        var filter = Ext.create('TSStringFilter',{query_string:query_string});

        Ext.create('Rally.data.WsapiDataStore',{
            model: model,
            autoLoad: true,
            limit: 'Infinity',
            filters: filter,
            fetch: ['ObjectID'],
            listeners: {
                scope: this,
                load: function(store,items,successful,opts){
                    this.logger.log("wsapi load",successful,opts);
                    if ( successful ) {
                        var oids = [];
                        Ext.Array.each(items, function(item){
                            oids.push(item.get('ObjectID'));
                        });
                        this.logger.log("back from wsapi with",oids);
                        deferred.resolve(oids);
                    } else {
                        deferred.reject("Error loading filter");
                    }
                }
            }
        });
        return deferred.promise;
    },
    _shouldUseSnap: function(snap) {
        if ( this.config.query_string ) {
            var oids = this.config.limit_to_oids;
            var oid = snap.get('ObjectID');
            return Ext.Array.contains(oids,oid);
        } else {
            return true;
        }
    },
    _recalculateLookBack: function(limit_to_oids) {
        var me = this;
        this.getEl().mask("Loading Historical Data");

        var config = this.config;
        this.logger.log("Getting array of days between",config.start_date,config.end_date,true,config.day_to_week_switch_point);
        var array_of_days = Rally.technicalservices.util.Utilities.arrayOfDaysBetween(config.start_date,config.end_date,true,config.day_to_week_switch_point);

        var promises = _.map(array_of_days,me._getSnapshots,this);
        promises.push(me._getValidFieldChoices(),this);

        Deft.Promise.all(promises).then({
            success: function(days) {
                // got back an array of calculated data for each day (tsday model) (plus the null back from the other call)
                days.pop();
                days.pop();
                me._makeChart(days);
            },
            failure: function(records) {
                console.log("oops");
            }
        });

    },
    _getValidFieldChoices: function() {
        this.logger.log("_getValidFieldChoices");
        var deferred = Ext.create('Deft.Deferred');
        var config = this.config;
        var me = this;

        config.groups = [];

        if ( config.group_by_field_type === "BOOLEAN" ) {
            config.groups = ["true","false"];
            deferred.resolve("x");
        } else {
            Rally.data.ModelFactory.getModel({
                type: config.model_type,
                success: function(model){
                    var field = model.getField(config.group_by_field_name);
                    field.getAllowedValueStore().load({
                        callback: function(values,operation,success) {
                            Ext.Array.each(values, function(value){
                                config.groups.push(value.get('StringValue'));
                            });
                            deferred.resolve("x");
                        }
                    });

                },
                scope: this
            });
        }

        return deferred.promise;
    },
    _getSnapshots:function(day){
        var me = this;
        var config = this.config;

        var deferred = Ext.create('Deft.Deferred');

        this.logger.log("fetching snapshots at", day);
        var project = this.getContext().getProject().ObjectID;
        var day_calculator = Ext.create('TSDay',{
            metricFieldName: config.metric,
            groupByFieldName:config.group_by_field_name,
            JSDate: day
        });

        if ( day < new Date() ) {
            Ext.create('Rally.data.lookback.SnapshotStore',{
                fetch: [config.group_by_field_name, config.metric],
                autoLoad: true,
                filters: [
                    {property:'_TypeHierarchy',value:config.model_type},
                    {property:'__At',operator:'=',value:Rally.util.DateTime.toIsoString(day)},
                    {property:'_ProjectHierarchy', value:project}
                ],
                hydrate: [config.group_by_field_name],
                listeners: {
                    load: function(store,snaps,success){
                        if (success) {
                            this.logger.log("snaps",snaps);

                            Ext.Array.each(snaps, function(snap){
                                if ( me._shouldUseSnap(snap) ) {
                                    day_calculator.addSnap(snap);
                                }
                            });
                            deferred.resolve(day_calculator);
                        } else {
                            deferred.reject("Error Loading Snapshots for " + day);
                        }
                    },
                    scope: this
                }
            });
            return deferred.promise;
        } else {
            return day_calculator;
        }
    },
    _getCategories: function(days) {
        var me = this;
        this.logger.log("_getCategories");
        var categories = [];
        Ext.Array.each(days,function(day){
            categories.push(day.get('JSDate'));
        });
        return categories;
    },
    _getSeries: function(days){
        this.logger.log("_getSeries");
        var group_data = {};
        var series = [];

        var groups = this.config.groups;
        Ext.Array.each(groups, function(group){
            group_data[group] = [];
        });

        Ext.Array.each(days, function(day){
            if ( day ) {
                Ext.Array.each(groups,function(group_name){
                    var group_value = day.getGroupTotal(group_name);
                    if ( day.get('JSDate') > new Date() ) {
                        group_value = null;
                    }
                    group_data[group_name].push(group_value);
                });
            }
        });

        Ext.Array.each(groups,function(group_name){
            var display_group_name = group_name;
            if ( group_name == "" ) { display_group_name = "None"; }
            series.push({
                type:'area',
                name: display_group_name,
                data: group_data[group_name]
            });
        });

        return series;
    },
    /*
     * determine what the distance between two x values is
     */
    _getIncrement: function(days){
        this.logger.log("_getIncrement");
        var increment = 0;
        if ( days.length > 1 ) {
            increment = Rally.util.DateTime.getDifference(days[1].get('JSDate'),days[0].get('JSDate'),'day');
        }
        this.logger.log("Increment",increment);
        return increment;
    },
    _makeChart: function(days) {
        var me = this;
        var config = this.config;

        this.logger.log("_makeChart",days);

        this.down('#chart_box').removeAll();

        var categories = this._getCategories(days);
        var series = this._getSeries(days);
        var increment = this._getIncrement(days);

        this.logger.log('categories',categories);
        this.logger.log('series',series);


        this.getEl().unmask();

        this.down('#chart_box').add({
            xtype:'rallychart',
            chartData: {
                series: series,
                categories: categories
            },
            chartConfig: {
                chart: {
                    type:'area'
                },
                title: {
                    text: config.model_type + " grouped by " + config.group_by_field_name,
                    align: 'center'
                },
                xAxis: [
                    {
                        categories: categories,
                        labels: {
                            align: 'left',
                            rotation: 70,
                            formatter: function() {
                                if ( increment < 1 ) {
                                    return Ext.Date.format(this.value,'H:i');
                                }
                                return Ext.Date.format(this.value,'d-M');
                            }
                        }
                    }
                ],
                yAxis: [
                    {title:
                        {text:config.metric}
                    }
                ],
                plotOptions: {
                    series: {
                        marker: { enabled: false },
                        stacking: 'normal'
                    }
                }
            }

        });
        if (this.config.query_string) {
            this.down('#chart_box').add({xtype:'container', html:'Filterd by: ' + this.config.query_string});
        }
    }
});

/**
 * the loading mask wasn't going away!
 */

Ext.override(Rally.ui.chart.Chart,{
    onRender: function () {
        this.callParent(arguments);
        this._unmask();
    }
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Super Customizable Cumulative Flow Diagram'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}

td[id^="rallyiterationcombobox-"] {
  width: 240px !important;
}

    </style>

</head>
<body></body>
</html>